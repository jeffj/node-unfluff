// Generated by CoffeeScript 1.12.7
(function() {
  var XRegExp, _, addNewlineToBr, cleanParagraphText, convertToHTML, convertToText, formatter, linksToText, removeFewwordsParagraphs, removeNegativescoresNodes, replaceWithText, stopwords, ulToText;

  stopwords = require("./stopwords");

  _ = require("lodash");

  XRegExp = require('xregexp').XRegExp;

  module.exports = formatter = function(doc, topNode, language, html) {
    removeNegativescoresNodes(doc, topNode);
    linksToText(doc, topNode);
    addNewlineToBr(doc, topNode);
    replaceWithText(doc, topNode);
    removeFewwordsParagraphs(doc, topNode, language);
    if (html) {
      return convertToHTML(doc, topNode);
    } else {
      return convertToText(doc, topNode);
    }
  };

  linksToText = function(doc, topNode) {
    var nodes;
    nodes = topNode.find('a');
    return nodes.each(function() {
      return doc(this).replaceWith(doc(this).html());
    });
  };

  ulToText = function(doc, node) {
    var nodes, txt;
    nodes = node.find('li');
    txt = "";
    nodes.each(function() {
      return txt = txt + ("\n * " + (doc(this).text()));
    });
    txt = txt + "\n";
    return txt;
  };

  replaceWithText = function(doc, topNode) {
    var nodes;
    nodes = topNode.find('b, strong, i, br, sup');
    return nodes.each(function() {
      return doc(this).replaceWith(doc(this).text());
    });
  };

  cleanParagraphText = function(rawText) {
    var txt;
    txt = rawText.trim();
    txt.replace(/[\s\t]+/g, ' ');
    return txt;
  };

  convertToHTML = function(doc, topNode) {
    var hangingText, nodes, txt, txts;
    txts = [];
    nodes = topNode.find("*");
    hangingText = "";
    nodes.each(function() {
      var attrs, newTxts, node, nodeName, nodeType, src, txt;
      node = doc(this);
      nodeType = node[0].type;
      nodeName = node[0].name;
      if (nodeType === "text") {
        hangingText += node.text();
        return true;
      } else if (nodeName === "ul") {
        hangingText += ulToText(doc, node);
        return true;
      }
      if (hangingText.length > 0) {
        txt = cleanParagraphText(hangingText);
        txts = txts.concat(txt);
        hangingText = "";
      }
      if (nodeName === "img") {
        attrs = node[0].attribs;
        src = '';
        if (attrs['src']) {
          src = attrs['src'];
        } else if (attrs['srcset']) {
          src = attrs['srcset'];
        } else if (attrs['data-src']) {
          src = attrs['data-src'];
        } else if (attrs['data-srcset']) {
          src = attrs['data-srcset'];
        }
        txts = txts.concat('<img src="' + src + '"/>');
      }
      console.log(node.text());
      newTxts = node.text().split('<br>');
      return newTxts.forEach(function(txt) {
        txt = cleanParagraphText(txt);
        if (txt.length > 0) {
          txt = txt.replace(/(\w+\.)([A-Z]+)/, '$1 $2');
          txt = txt.split(/\r?\n/);
          return txts = txts.concat(txt);
        }
      });
    });
    if (hangingText.length > 0) {
      txt = cleanParagraphText(hangingText);
      txt = txt.split(/\r?\n/);
      txts = txts.concat(txt);
    }
    txts = txts.filter(function(txt) {
      return txt.length > 0;
    });
    txts = txts.map(function(txt) {
      return '<p>' + txt + '</p>';
    });
    return txts.join('');
  };

  convertToText = function(doc, topNode) {
    var hangingText, nodes, regex, txt, txts;
    txts = [];
    nodes = topNode.contents();
    hangingText = "";
    nodes.each(function() {
      var node, nodeName, nodeType, txt;
      node = doc(this);
      nodeType = node[0].type;
      nodeName = node[0].name;
      if (nodeType === "text") {
        hangingText += node.text();
        return true;
      } else if (nodeName === "ul") {
        hangingText += ulToText(doc, node);
        return true;
      }
      if (hangingText.length > 0) {
        txt = cleanParagraphText(hangingText);
        txts = txts.concat(txt.split(/\r?\n/));
        hangingText = "";
      }
      txt = cleanParagraphText(node.text());
      txt = txt.replace(/(\w+\.)([A-Z]+)/, '$1 $2');
      return txts = txts.concat(txt.split(/\r?\n/));
    });
    if (hangingText.length > 0) {
      txt = cleanParagraphText(hangingText);
      txts = txts.concat(txt.split(/\r?\n/));
    }
    txts = _.map(txts, function(txt) {
      return txt.trim();
    });
    regex = XRegExp('[\\p{Number}\\p{Letter}]');
    txts = _.filter(txts, function(txt) {
      return regex.test(txt);
    });
    return txts.join('\n\n');
  };

  addNewlineToBr = function(doc, topNode) {
    var brs;
    brs = topNode.find("br");
    return brs.each(function() {
      var br;
      br = doc(this);
      return br.replaceWith("\n\n");
    });
  };

  removeNegativescoresNodes = function(doc, topNode) {
    var gravityItems;
    gravityItems = topNode.find("*[gravityScore]");
    return gravityItems.each(function() {
      var item, score;
      item = doc(this);
      score = parseInt(item.attr('gravityScore')) || 0;
      if (score < 1) {
        return doc(item).remove();
      }
    });
  };

  removeFewwordsParagraphs = function(doc, topNode, language) {
    var allNodes;
    allNodes = topNode.find("*");
    return allNodes.each(function() {
      var el, stopWords, tag, text, trimmed;
      el = doc(this);
      tag = el[0].name;
      text = el.text();
      if (tag === 'img' || el.find('img').length > 0) {
        return false;
      }
      stopWords = stopwords(text, language);
      if ((tag !== 'br' || text !== '\\r') && stopWords.stopwordCount < 3 && el.find("object").length === 0 && el.find("embed").length === 0) {
        return doc(el).remove();
      } else {
        trimmed = text.trim();
        if (trimmed[0] === "(" && trimmed[trimmed.length - 1] === ")") {
          return doc(el).remove();
        }
      }
    });
  };

}).call(this);
